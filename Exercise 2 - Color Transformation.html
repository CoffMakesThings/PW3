<!--
	CIE L*C*h - hue shifting (with sRGB colors).
		o Parameters: shifting angle in degree
-->

<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
			margin: 0;
			padding: 0;
			width: 100%;
			height: 100%;
			
			margin: 0;
			overflow: hidden;
			background-color: #AAAAAA;
			background-attachment: fixed !important;
			}
		</style>
		<style>
			body {
				font-family: Monospace;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

	<script id="vertShader" type="shader">
		precision highp float;
	
		void main() {
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );
		}
	</script>

	<script id="fragShaderColorTransformation" type="shader">
		uniform sampler2D image;
		uniform mat3 rgb2xyzMatrix;
		uniform bool useAngle;
		uniform float angle;
	
		out vec4 out_FragColor;

		float delta = 6. / 29.;
		float Xn = 95.0489;
		float Yn = 100.;
		float Zn = 108.8840;

		float srgb2linear(float Csrgb) {
			if (Csrgb <= 0.04045) {
				return Csrgb / 12.92;
			} else {
				return pow((Csrgb + 0.055) / 1.055, 2.);
			}
		}

		vec3 rgb2xyz(vec3 rgb) {
			vec3 RGB = vec3(srgb2linear(rgb.r), srgb2linear(rgb.g), srgb2linear(rgb.b));
			return RGB * rgb2xyzMatrix;
		}

		float f(float t) {
			if (t > pow(delta, 3.)) {
				return pow(t, 1. / 3.);
			} else {
				return t / pow(delta, 2.) + 4. / 29.;
			}
		}

		vec3 xyz2lab(vec3 xyz)
		{
			float X = xyz.x * 100.;
			float Y = xyz.y * 100.;
			float Z = xyz.z * 100.;
			float L = 116. * f(Y / Yn) - 16.;
			float a = 500. * (f(X / Xn) - f(Y / Yn));
			float b = 200. * (f(Y / Yn) - f(Z / Zn));
			return vec3(L / 100., a / 100., b / 100.);
		}

		vec3 lab2lch(vec3 lab)
		{
			float L = lab.x;
			float a = lab.y;
			float b = lab.z;
			float C = sqrt(pow(a, 2.) + pow(b, 2.));
			float h = atan(b / a);
			return vec3(L, C, h);
		}

		vec3 rgb2lch(vec3 rgb) {
			return lab2lch(xyz2lab(rgb2xyz(rgb)));
		}

		void main(void) {
			float sampleX = gl_FragCoord.x;
			float sampleY = gl_FragCoord.y;

			vec4 value = texelFetch(image, ivec2(int(sampleX), int(sampleY)), 0);

			if (useAngle) {
				out_FragColor = vec4(rgb2lch(value.rgb).xy, angle, 1);
			} else {
				out_FragColor = vec4(rgb2lch(value.rgb), 1);
			}
			// out_FragColor = vec4(rgb2xyz(value.rgb), 1);
		}
	</script>
<script type="module">

import * as THREE from 'https://cdn.skypack.dev/three@0.136.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';
import { GUI } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/libs/lil-gui.module.min.js';
import { WEBGL } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/WebGL.js';

var camera, controls, scene, renderer, container;
var context, canvas;
var plane1;
var plane2;
var loaderPromise, video, videoTexture;
var colorTransformationHandler;
var verticalGaussianHandler;
var gui;
var guiObject;
var rgb2xyzMatrix = new THREE.Matrix3();
rgb2xyzMatrix.set(0.4124, 0.3576, 0.1805,
0.2126, 0.7152, 0.0722,
0.0193, 0.1192, 0.9505);

// Setup image processing
class ImageProcessingHandler {
	constructor( height, width, imageProcessingMaterial ) {
		this.height = height;
		this.width = width;

		this.scene = new THREE.Scene();
		this.orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1 / Math.pow( 2, 53 ), 1 );

		var options = {
			minFilter: THREE.NearestFilter,
			magFilter: THREE.NearestFilter,
			format: THREE.RGBAFormat,
			type: THREE.FloatType,
			canvas: canvas, 
			context: context
		};

		// this.rtt = new THREE.WebGLRenderTarget( width, height, options);
		this.rtt = new THREE.WebGLRenderTarget( width, height, options);

		var geom = new THREE.BufferGeometry();
		geom.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0 ]), 3 ) );
		var mesh = new THREE.Mesh( geom, imageProcessingMaterial );
		this.scene.add( new THREE.Mesh( geom, imageProcessingMaterial ) );
	} 
}

function processImage ( imageProcessing, renderer )
{
	renderer.setRenderTarget( imageProcessing.rtt );
	renderer.render ( imageProcessing.scene, imageProcessing.orthoCamera ); 	
	renderer.setRenderTarget( null );
};

// Load sourceImage url param
const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);
var sourceImage = urlParams.get('sourceimage')
console.log("sourceImage is " + sourceImage);

if (sourceImage == null) {
	console.log("Defaulting sourceImage to image")
	sourceImage = 'image';
	console.log("sourceImage is " + sourceImage); 
}

// Load video from webcam
if (sourceImage == 'webcam') {
	loaderPromise = new Promise((resolve) => {
		if ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {
			const constraints = { video: { width: 1920, height: 1080, facingMode: 'user' } };
			resolve(navigator.mediaDevices.getUserMedia( constraints ));
		}
	}).then(stream => {
		return new Promise(resolve => {
			video = document.createElement('video');
			video.srcObject = stream;
			video.play();

			video.onloadeddata = () => { 
				videoTexture = new THREE.VideoTexture( video );
				videoTexture.minFilter = THREE.NearestFilter;
				videoTexture.magFilter = THREE.NearestFilter;
				videoTexture.generateMipmaps = false; 
				videoTexture.format = THREE.RGBFormat;

				resolve();
			}
		});
	});
}

// Load video from file
if (sourceImage == 'video') {
	video = document.createElement('video');
	video.src = 'video.mp4';
	video.load();
	video.muted = true;
	video.loop = true;

	loaderPromise = new Promise((resolve) => {
		video.onloadeddata = function () 
		{
			videoTexture = new THREE.VideoTexture( video );
			videoTexture.minFilter = THREE.NearestFilter;
			videoTexture.magFilter = THREE.NearestFilter;
			videoTexture.generateMipmaps = false; 
			videoTexture.format = THREE.RGBFormat;
			video.play();

			resolve();
		}
	});
}

// Load image
var imageTexture;

if (sourceImage == 'image') {
	loaderPromise = new Promise((resolve) => {
		imageTexture = new THREE.TextureLoader().load( 'grenouille.jpg', () => resolve() );
	});
}

loaderPromise.then(() => {
	init();
	animate();
});

function degToRad(degrees)
{
  var pi = Math.PI;
  return degrees * (pi/180);
}

function init () {
    if ( WEBGL.isWebGL2Available() === false ) {
		document.body.appendChild( WEBGL.getWebGL2ErrorMessage() );
	}	
    container = document.createElement( 'div' );
	document.body.appendChild( container );
	
    canvas = document.createElement( 'canvas' );
	context = canvas.getContext( 'webgl2' );
	document.body.appendChild( canvas );

	scene = new THREE.Scene(); 

	renderer = new THREE.WebGLRenderer( {  canvas: canvas, context: context});
	renderer.autoClear = false;
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.shadowMap.enabled = false;

	container.appendChild( renderer.domElement );

	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.001, 10 );
	camera.position.z = 0.7;
	controls = new OrbitControls( camera, renderer.domElement );
	controls.minDistance = 0.005;
	controls.maxDistance = 1.0;
	controls.enableRotate = true;
	controls.addEventListener( 'change', render );
	controls.update();
	
	var texture, aspect, width, height;

	switch(sourceImage) {
		case 'video':
		case 'webcam':
			texture = videoTexture;
			width = video.videoWidth;
			height = video.videoHeight;
			break;
		default:
			console.log(imageTexture);
			texture = imageTexture;
			width = imageTexture.image.width;
			height = imageTexture.image.height;
	}

	var aspect = height / width;
	var geometry = new THREE.PlaneGeometry( 1, aspect );

	var colorTransformationMaterial = new THREE.ShaderMaterial({
    	uniforms: {
			image: {type: 't', value: texture},
			rgb2xyzMatrix: {value: rgb2xyzMatrix},
			useAngle: { type: 'b', value: false },
			angle: { type: 'f', value: 0 }
    	},
    	vertexShader: document.getElementById('vertShader').text,
    	fragmentShader: document.getElementById('fragShaderColorTransformation').text,
        glslVersion: THREE.GLSL3
	});

	colorTransformationHandler = new ImageProcessingHandler ( height, width, colorTransformationMaterial );

	// GUI

	gui = new GUI();

	gui.add(colorTransformationMaterial.uniforms.useAngle, 'value').name('Use angle');
	gui.add(colorTransformationMaterial.uniforms.angle, 'value', -Math.PI * 4, Math.PI * 4).name('Angle');

	var material1 = new THREE.MeshBasicMaterial( { map: texture, side: THREE.DoubleSide } );
	var material2 = new THREE.MeshBasicMaterial( { map: colorTransformationHandler.rtt.texture, side : THREE.DoubleSide } );

	plane1 = new THREE.Mesh( geometry, material1 );
	plane1.receiveShadow = false;
	plane1.castShadow = false;
	scene.add( plane1 );

	plane2 = new THREE.Mesh( geometry, material2 );
	plane2.receiveShadow = false;
	plane2.castShadow = false;
	scene.add( plane2 );

	// Tilt the planes towards the camera

	var angle = degToRad(0);
	var distance = Math.cos(angle) / 2;

	plane1.position.x -= distance;
	plane1.rotation.y = angle;
	plane2.position.x += distance;
	plane2.rotation.y = -angle;

	window.addEventListener( 'resize', onWindowResize, false );
}

function render () {
	renderer.clear();

	if (colorTransformationHandler) {
		processImage ( colorTransformationHandler, renderer );
	}

	renderer.render( scene, camera );
}

function animate() {	
	requestAnimationFrame(animate);
	controls.update();
	render();
}

function onWindowResize () {
	camera.aspect = ( window.innerWidth / window.innerHeight);
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );
	render();
}

</script>
</body>
</html>